#!/usr/bin/env python

# python libraries
import sys, optparse

# dlcpar libraries
from dlcpar import common
from dlcpar import reconlib

# rasmus libraries
from rasmus import treelib, util

#===========================================================================
# parser

def parse_args():
    """parse input arguments"""
    parser = optparse.OptionParser(usage="%prog [options] <gene tree> ...")
    parser.add_option("-n", dest="times", metavar="<number of times>",
                      default=100, type="int",
                      help="number of equivalent LCTs to generate, default 100")
    parser.add_option("-s", "--stree", dest="stree", metavar="<species tree>",
                      help="species tree file in newick format")
    parser.add_option("-I", "--inputext", dest="inputext",
                      metavar="<input file extension>",
                      default=".tree",
                      help="input file extension (default: \".tree\")")
    parser.add_option("-O", "--outputext", dest="outputext", 
                      metavar="<output file extension>",
                      default=".eq",
                      help="output file extension (default: \".dlcpar.eq\")")
    options, args = parser.parse_args()

    if len(args) != 1:
        parser.error("must specify one lct")
    if not options.stree:
        parser.error("-s/--stree required")

    return options, args


#===========================================================================
# main
def generate_equal_labeled_recon(labeled_recon):
    """ Randomly generate a labeled recon (LCT) that is equivalent to the input one
    """
    from itertools import permutations
    import random

    # species map and locus map have to be exactly the same
    species_map = dict(labeled_recon.species_map)
    locus_map = dict(labeled_recon.locus_map)
    order = {}
    for snode, d in labeled_recon.order.iteritems():
        order[snode] = {}
        for locus, lst in d.iteritems():
            order[snode][locus] = list(lst)
    
    LCT = reconlib.LabeledRecon(species_map, locus_map, order) 

    # if there is no partial ordering, return
    if not order:
        return LCT

    # randomly choose an ordering (species, locus) to change
    random_species = random.choice(order.keys())
    order_loci = order[random_species]
    random_locus = random.choice(order_loci.keys())
    gnodes = order_loci[random_locus] # list of genes

    # get all duplication nodes
    dups = LCT.get_dups()

    # get groupings
    groupings = [] # [list_of_genes gene_with_dup list_of_genes ...]
    start_index = 0
    for i, gnode in enumerate(gnodes):
        if gnode.name in dups:
            groupings.append(gnodes[start_index:i])
            groupings.append([gnodes[i]])
            start_index = i + 1
    groupings.append(gnodes[start_index:])

    # permute within each group
    new_gnodes = [] # new list of genes

    for group in groupings:
        if len(group) > 1: # only do it on groups that actually have multiple elements
            all_permutations = list(permutations(group))
            # get constraints (children can't go before parent)
            constraints = []
            for node in group:
                for child in node.children:
                    if child in group:
                        constraints.append((node, child))
            # get rid of all the illegal permutations
            '''for permutation in list(all_permutations):
                for constraint in constraints:
                    parent = constraint[0]
                    child = constraint[1]
                    parent_index = permutation.index(parent)
                    child_index = permutation.index(child)
                    if parent_index > child_index:
                        all_permutations.remove(permutation)
                        break
            '''
            # randomly choose a new ordering from all legal ones
            new_gnodes.extend(random.choice(all_permutations))
        else:
            new_gnodes.extend(group)

    order[random_species][random_locus] = new_gnodes

    return LCT


def main():
    """main"""
    
    # parse arguments
    options, args = parse_args()

    # read species tree
    stree = treelib.read_tree(options.stree)
    common.check_tree(stree, options.stree)

    # read files
    prefix = util.replace_ext(args[0], options.inputext, "")
    lct1 = reconlib.LabeledRecon()
    gene_tree, extra = lct1.read(prefix, stree)

    # generate new lcts
    result = []
    for i in xrange(options.times):
        out = util.replace_ext(args[0], options.inputext, options.outputext) + ".%d" % i 
        lct2 = generate_equal_labeled_recon(lct1)
        lct2.write(out, gene_tree)
        eq = lct1 == lct2
        result.append(eq)
        print "%d\t%s" %(i, str(eq))


if __name__ == "__main__":
    sys.exit(main())
